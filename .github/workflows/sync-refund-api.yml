name: Sync API Spec → Generate Collection → Link API

on:
  push:
    paths:
      - "specs/**/*.yaml"
      - "specs/**/*.yml"
      - "specs/**/*.json"

jobs:
  sync-api:
    runs-on: ubuntu-latest
    
    # Exit immediately if a command fails
    defaults:
      run:
        shell: bash -e {0}

    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v4 

      #######################################################################
      # 1. Read Spec File and Get File Path
      #######################################################################
      - name: Load Spec File Path and Type
        id: loadspec
        run: |
          # Finds the single spec file regardless of extension
          FILE=$(ls specs/payment-refund-api-openapi.*)
          
          if [[ "$FILE" =~ \.(yaml|yml)$ ]]; then
              LANG="yaml"
          elif [[ "$FILE" =~ \.json$ ]]; then
              LANG="json"
          else
              echo "Error: Unsupported file extension for $FILE"
              exit 1
          fi

          echo "Spec file found: $FILE"
          echo "specfile=$FILE" >> $GITHUB_OUTPUT

      #######################################################################
      # 1.5 SANITIZE SPEC FILE CONTENT (Ensuring clean transmission)
      #######################################################################
      - name: Sanitize YAML File Encoding
        run: |
          FILE="${{ steps.loadspec.outputs.specfile }}"
          iconv -c -f utf-8 -t utf-8 "$FILE" | tr -d '\r' > "${FILE}.tmp"
          mv "${FILE}.tmp" "$FILE"
          echo "File encoding sanitized."

      #######################################################################
      # 2. PUBLISH SPEC via POSTMAN CLI (Fixing EACCES)
      #######################################################################
      - name: Publish Spec via Postman CLI
        id: postman_import
        run: |
          API_ID="4351c3b1-def3-4d95-9ef5-4ce0dcc42853" 
          WORKSPACE_ID="2bf1dd30-2897-4f0d-abf9-4a02d2970785" 
          FILE="${{ steps.loadspec.outputs.specfile }}"
          
          # CRITICAL FIX: Use sudo to grant permission for global install
          sudo npm install -g postman-cli
          
          echo "Using Postman CLI to import spec to API ID: $API_ID"
          
          # Use a timestamped version name
          VERSION_NAME="v2.1.0-build-$(date +%Y%m%d%H%M%S)"

          # CRITICAL STEP: Use the CLI command to sync the spec. 
          CLI_OUTPUT=$(postman api import "$FILE" \
            --base-api-id "$API_ID" \
            --base-api-version "$VERSION_NAME" \
            --workspace-id "$WORKSPACE_ID" \
            --postman-api-key ${{ secrets.POSTMAN_API_KEY }})

          echo "Postman CLI Output:"
          echo "$CLI_OUTPUT"

          # Parse the output to get the created Collection ID
          # The CLI output contains a line like: "Successfully imported to collection [Collection Name] (ID)"
          COLLECTION_ID=$(echo "$CLI_OUTPUT" | grep "collection" | tail -1 | awk '{print $NF}' | tr -d '[:punct:]')
          
          if [ -z "$COLLECTION_ID" ]; then
             echo "CRITICAL ERROR: Failed to parse Collection ID from Postman CLI output. Check CLI log above."
             exit 1
          fi

          echo "Successfully created and linked Collection ID: $COLLECTION_ID"
          echo "collection_id=$COLLECTION_ID" >> $GITHUB_OUTPUT
          

      #######################################################################
      # 3. Attach JWT Pre-request Script (Collection Update)
      #######################################################################
      - name: Inject JWT Script
        run: |
          COLLECTION_ID="${{ steps.postman_import.outputs.collection_id }}"
          API_KEY="${{ secrets.POSTMAN_API_KEY }}"

          echo "Injecting JWT pre-request script into collection $COLLECTION_ID"
          
          # Create JWT payload using jq for robustness
          JWT_PAYLOAD=$(jq -n \
            '{"collection": {"event": [{
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// JWT Auth Script: Use pm.environment.get(\"clientId\") for client/token details",
                  "const clientId = pm.environment.get(\"clientId\");",
                  "const clientSecret = pm.environment.get(\"clientSecret\");",
                  "const tokenUrl = pm.environment.get(\"tokenUrl\");",
                  "pm.sendRequest({",
                  "  url: tokenUrl,",
                  "  method: \"POST\",",
                  "  header: { \"Content-Type\": \"application/x-www-form-urlencoded\" },",
                  "  body: \"client_id=\" + clientId + \"&client_secret=\" + clientSecret + \"&grant_type=client_credentials\"",
                  "}, function(err, res) { pm.environment.set(\"jwtToken\", res.json().access_token); });"
                ]
              }
            }]}}')

          curl -s -X PUT \
            "https://api.getpostman.com/collections/$COLLECTION_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "$JWT_PAYLOAD"

      #######################################################################
      # 4. (Optional) Run Tests Using Newman
      #######################################################################
      - name: Run Tests
        run: |
          COLLECTION_ID="${{ steps.postman_import.outputs.collection_id }}"

          npm install newman
          echo "Running Newman tests on generated collection $COLLECTION_ID..."
          
          npx newman run "https://api.getpostman.com/collections/$COLLECTION_ID?apikey=${{ secrets.POSTMAN_API_KEY }}"
