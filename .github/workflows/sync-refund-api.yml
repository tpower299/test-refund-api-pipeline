name: Sync API Spec â†’ Generate Collection (Completed Adoption Kit)

on:
  push:
    paths:
      - "specs/**/*.yaml"
      - "specs/**/*.yml"
      - "specs/**/*.json"
  workflow_dispatch:

jobs:
  sync-api:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        shell: bash -e {0}
        
    env:
      POSTMAN_WORKSPACE_ID: ${{ secrets.POSTMAN_WORKSPACE_ID }} 
      POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
      # Your verified Mock Server URL
      MOCK_SERVER_URL: https://ac1d1bb2-eba1-4c5e-b492-9483f4410770.mock.pstmn.io
      # Public URL for mocking token acquisition (JWT script dependency)
      AUTH_SERVER_URL: https://postman-echo.com/post
      
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v4
      - name: Install Dependencies
        run: |
          npm install -g openapi-to-postmanv2 newman
          sudo apt-get install -y jq

      #######################################################################
      # 1. Detect File & Extract Name (Dynamic)
      #######################################################################
      - name: Detect Spec File and Name
        id: spec
        run: |
          # Find the first YAML or JSON file in the specs folder
          FILE=$(find specs -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) | head -n 1)
          
          if [ -z "$FILE" ]; then
            echo "Error: No spec file found in specs/ folder"
            exit 1
          fi

          # Sanitize file (encoding)
          iconv -c -f utf-8 -t utf-8 "$FILE" | tr -d '\r' > "$FILE.tmp"
          mv "$FILE.tmp" "$FILE"
          
          # Extract the 'title' from the spec to use as the Name in Postman
          # Fallback to filename if title is not found
          SPEC_NAME=$(grep -m 1 "title:" "$FILE" | sed 's/.*title: *//' | tr -d '"' | tr -d "'" | tr -d '\r')
          if [[ -z "$SPEC_NAME" ]]; then
            SPEC_NAME=$(basename "$FILE")
          fi
          
          echo "Found File: $FILE"
          echo "Spec Name: $SPEC_NAME"
          
          echo "specfile=$FILE" >> $GITHUB_OUTPUT
          echo "specname=$SPEC_NAME" >> $GITHUB_OUTPUT

      #######################################################################
      # 2. UPSERT SPEC IN SPEC HUB (Create or Update)
      #######################################################################
      - name: Upsert Spec in Spec Hub
        id: create_spec
        run: |
          SPEC_NAME="${{ steps.spec.outputs.specname }}"
          FILE="${{ steps.spec.outputs.specfile }}"
          
          # 1. Check if Spec exists in Workspace
          LIST_RESPONSE=$(curl -s -X GET "https://api.getpostman.com/specs?workspaceId=$POSTMAN_WORKSPACE_ID" \
            -H "X-Api-Key: $POSTMAN_API_KEY")
            
          EXISTING_ID=$(echo "$LIST_RESPONSE" | jq -r --arg name "$SPEC_NAME" '.specs[] | select(.name == $name) | .id')

          # 2. Prepare Payload
          PAYLOAD=$(jq -n \
            --rawfile spec_content "$FILE" \
            --arg name "$SPEC_NAME" \
            '{ name: $name, type: "OPENAPI:3.0", files: [{ path: "index.yaml", content: $spec_content }] }')

          if [ -n "$EXISTING_ID" ] && [ "$EXISTING_ID" != "null" ]; then
            echo "Spec '$SPEC_NAME' exists (ID: $EXISTING_ID). Updating..."
            
            # PERFORM UPDATE (PUT)
            curl -s -X PUT \
              "https://api.getpostman.com/specs/$EXISTING_ID" \
              -H "X-Api-Key: $POSTMAN_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD" > /dev/null
              
            echo "spec_id=$EXISTING_ID" >> $GITHUB_OUTPUT
          else
            echo "Spec '$SPEC_NAME' does not exist. Creating..."
            
            # PERFORM CREATE (POST)
            RESPONSE=$(curl -s -X POST \
              "https://api.getpostman.com/specs?workspaceId=$POSTMAN_WORKSPACE_ID" \
              -H "X-Api-Key: $POSTMAN_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD")
              
            NEW_ID=$(echo "$RESPONSE" | jq -r '.spec.id')
            echo "spec_id=$NEW_ID" >> $GITHUB_OUTPUT
          fi

      #######################################################################
      # 3. GENERATE COLLECTION LOCALLY
      #######################################################################
      - name: Generate Collection Locally
        id: local_gen
        run: |
          npx openapi-to-postmanv2 \
            -s ${{ steps.spec.outputs.specfile }} \
            -o collection.json

      #######################################################################
      # 4. UPLOAD/UPDATE COLLECTION (Initial Upload)
      #######################################################################
      - name: Upload or Update Collection (Initial Upload)
        id: upload_collection
        run: |
          PAYLOAD=$(jq -n \
            --rawfile collection_content collection.json \
            '{collection: ($collection_content | fromjson)}' )
            
          HTTP_CODE=$(curl -X POST \
            "https://api.getpostman.com/collections?workspaceId=$POSTMAN_WORKSPACE_ID" \
            -H "X-Api-Key: $POSTMAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            -o response_body.json \
            -w "%{http_code}")
          
          RESPONSE_BODY=$(cat response_body.json)
          COLLECTION_ID=$(echo "$RESPONSE_BODY" | jq -r '.collection.id')
          if [[ "$HTTP_CODE" != "200" || -z "$COLLECTION_ID" || "$COLLECTION_ID" == "null" ]]; then
            echo "CRITICAL ERROR: Failed to upload collection."
            echo "HTTP STATUS: $HTTP_CODE"
            echo "RAW RESPONSE BODY: $RESPONSE_BODY"
            exit 1
          fi
          echo "SUCCESS: Collection uploaded. ID: $COLLECTION_ID"
          echo "collection_id=$COLLECTION_ID" >> $GITHUB_OUTPUT

      #######################################################################
      # 5. Inject JWT Pre-request Script (Fetch-Modify-Put Pattern)
      #######################################################################
      - name: Inject Advanced JWT Script
        run: |
          COLLECTION_ID="${{ steps.upload_collection.outputs.collection_id }}"
          API_KEY="$POSTMAN_API_KEY"

          # 5a. Fetch Collection
          FULL_COLLECTION_RESPONSE=$(curl -s -X GET "https://api.getpostman.com/collections/$COLLECTION_ID" -H "X-Api-Key: $API_KEY")
          
          if echo "$FULL_COLLECTION_RESPONSE" | jq -e '.collection' > /dev/null; then
              FULL_COLLECTION=$(echo "$FULL_COLLECTION_RESPONSE" | jq '.collection')
          else
              echo "CRITICAL ERROR: Failed to fetch collection for modification (ID: $COLLECTION_ID). Check API Key permissions."
              exit 1
          fi
          
          # 5b. Define and Modify (Advanced JWT Script)
          JWT_SCRIPT='[ { "listen": "prerequest", "script": { "type": "text/javascript", "exec": [ "// Advanced JWT Auth: Checks expiry and refreshes token", "const clientId = pm.environment.get(\"clientId\");", "const clientSecret = pm.environment.get(\"clientSecret\");", "const tokenUrl = pm.environment.get(\"tokenUrl\");", "const cachedToken = pm.environment.get(\"jwtToken\");", "const tokenExpiry = parseInt(pm.environment.get(\"tokenExpiry\"));", "", "// Check if token is valid (exists AND expiry time is > 30s in the future)", "if (cachedToken && tokenExpiry && Date.now() < (tokenExpiry - 30000)) {", "    pm.request.headers.upsert({key: \"Authorization\", value: \"Bearer \" + cachedToken});", "    return; // Skip token request", "}", "", "// Request new token", "pm.sendRequest({", "    url: tokenUrl,", "    method: \"POST\",", "    header: {\"Content-Type\": \"application/x-www-form-urlencoded\"},", "    body: {mode: \"urlencoded\", urlencoded: [{key: \"grant_type\", value: \"client_credentials\"}, {key: \"client_id\", value: clientId}, {key: \"client_secret\", value: clientSecret}]} ", "}, (err, response) => {", "    if (err || response.code !== 200) {", "        console.error(\"Token request failed:\", err || response.status);", "        return;", "    }", "    const jsonData = response.json();", "    const token = jsonData.access_token;", "    const expires_in_ms = jsonData.expires_in * 1000; ", "    pm.environment.set(\"jwtToken\", token);", "    pm.environment.set(\"tokenExpiry\", Date.now() + expires_in_ms);", "    pm.request.headers.upsert({key: \"Authorization\", value: \"Bearer \" + token});", "});" ] } } ]'
                      
          MODIFIED_PAYLOAD=$(echo "$FULL_COLLECTION" | jq --argjson script_event "$JWT_SCRIPT" '. + {event: $script_event}')
                    
          # 5c. Push Update (PUT)
          curl -s -X PUT \
            "https://api.getpostman.com/collections/$COLLECTION_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"collection\": $MODIFIED_PAYLOAD}" > /dev/null
          
          echo "SUCCESS: Collection updated with advanced JWT script."

      #######################################################################
      # 6. CREATE DEV ENVIRONMENT (Required Component)
      #######################################################################
      - name: Create Base Dev Environment
        id: create_env
        run: |
          ENV_PAYLOAD=$(jq -n \
            --arg baseUrl "$MOCK_SERVER_URL" \
            --arg tokenUrl "$AUTH_SERVER_URL" \
            '{
              "environment": {
                "name": "Payment Processing - Dev",
                "values": [
                  { "key": "baseUrl", "value": $baseUrl, "enabled": true },
                  { "key": "tokenUrl", "value": $tokenUrl, "enabled": true },
                  { "key": "clientId", "value": "dev-client-id-internal", "enabled": true },
                  { "key": "clientSecret", "value": "dev-secret-internal", "enabled": true },
                  { "key": "jwtToken", "value": "", "enabled": true },
                  { "key": "tokenExpiry", "value": "0", "enabled": true }
                ]
              }
            }')
          HTTP_CODE=$(curl -X POST \
            "https://api.getpostman.com/environments?workspaceId=$POSTMAN_WORKSPACE_ID" \
            -H "X-Api-Key: $POSTMAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$ENV_PAYLOAD" \
            -o response_env_body.json \
            -w "%{http_code}")
          
          RESPONSE_BODY=$(cat response_env_body.json)
          ENV_ID=$(echo "$RESPONSE_BODY" | jq -r '.environment.id')
          
          if [[ "$HTTP_CODE" != "200" || -z "$ENV_ID" || "$ENV_ID" == "null" ]]; then
            echo "WARNING: Environment creation failed (possibly exists or API Key issue). Status: $HTTP_CODE"
            echo "RAW RESPONSE BODY: $RESPONSE_BODY"
           else
            echo "SUCCESS: Dev Environment created. ID: $ENV_ID"
          fi

      #######################################################################
      # 7. Run tests using Newman (Final CI/CD Check)
      #######################################################################
      - name: Run Tests (Newman Validation)
        run: |
          COLLECTION_ID="${{ steps.upload_collection.outputs.collection_id }}"
          echo "Running Newman tests against your Mock Server (CI/CD validation)..."
          
          # Using MOCK_SERVER_URL and AUTH_SERVER_URL environment variables directly
          npx newman run "https://api.getpostman.com/collections/$COLLECTION_ID?apikey=$POSTMAN_API_KEY" \
            --insecure \
            --env-var "baseUrl=$MOCK_SERVER_URL" \
            --env-var "tokenUrl=$AUTH_SERVER_URL" \
            --env-var "clientId=mock_client" \
            --env-var "clientSecret=mock_secret"
            
          echo "Newman run complete."
