name: Sync API Spec → Generate Collection → Link API

on:
  push:
    paths:
      - "specs/**/*.yaml"
      - "specs/**/*.yml"
      - "specs/**/*.json"

jobs:
  sync-api:
    runs-on: ubuntu-latest
    
    # Exit immediately if a command fails
    defaults:
      run:
        shell: bash -e {0}

    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v4 # Ensure Node.js is available for Newman/npm

      #######################################################################
      # 1. Read Spec File and Get File Path
      #######################################################################
      - name: Load Spec File Path and Type
        id: loadspec
        run: |
          # Finds the single spec file regardless of extension
          FILE=$(ls specs/payment-refund-api-openapi.*)
          
          if [[ "$FILE" =~ \.(yaml|yml)$ ]]; then
              LANG="yaml"
          elif [[ "$FILE" =~ \.json$ ]]; then
              LANG="json"
          else
              echo "Error: Unsupported file extension for $FILE"
              exit 1
          fi

          echo "Spec file found: $FILE"
          echo "specfile=$FILE" >> $GITHUB_OUTPUT
          echo "file_type=$LANG" >> $GITHUB_OUTPUT

      #######################################################################
      # 1.5 SANITIZE SPEC FILE CONTENT (Fixes invisible character errors)
      #######################################################################
      - name: Sanitize YAML File Encoding
        run: |
          FILE="${{ steps.loadspec.outputs.specfile }}"
          
          # Use iconv to strip non-standard characters and tr to ensure LF line endings.
          iconv -c -f utf-8 -t utf-8 "$FILE" | tr -d '\r' > "${FILE}.tmp"
          mv "${FILE}.tmp" "$FILE"
          echo "File encoding sanitized."

      #######################################################################
      # DIAGNOSTIC CHECK: Validate API Key has access to Workspace ID
      #######################################################################
      - name: Validate Workspace Access
        id: workspace_check
        run: |
          WORKSPACE_ID="2bf1dd30-2897-4f0d-abf9-4a02d2970785"
          API_KEY="${{ secrets.POSTMAN_API_KEY }}"

          echo "Attempting to retrieve Workspace ID: $WORKSPACE_ID"

          RESPONSE=$(curl -s -X GET \
            "https://api.getpostman.com/workspaces/$WORKSPACE_ID" \
            -H "X-Api-Key: $API_KEY")

          ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message')
          
          if [ -n "$ERROR_MESSAGE" ] && [ "$ERROR_MESSAGE" != "null" ]; then
            echo "--- WORKSPACE ACCESS ERROR ---"
            echo "The API Key does NOT have access to Workspace ID: $WORKSPACE_ID."
            echo "Postman API Response: $ERROR_MESSAGE"
            exit 1
          else
            WORKSPACE_NAME=$(echo "$RESPONSE" | jq -r '.workspace.name')
            echo "SUCCESS: API Key successfully authenticated and retrieved workspace: $WORKSPACE_NAME"
            echo "---"
            echo "Starting API Synchronization..."
          fi


      #######################################################################
      # 2. PUBLISH SPEC via POSTMAN REST API (TESTING STATIC JSON PAYLOAD)
      #######################################################################
      - name: Publish Spec via Postman REST API (cURL)
        id: postman_import
        # Define key variables in the GitHub Actions environment block for maximum stability
        env:
          API_ID_FINAL: 4351c3b1-def3-4d95-9ef5-4ce0dcc42853
          API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          WORKSPACE_ID: 2bf1dd30-2897-4f0d-abf9-4a02d2970785
          FILE_PATH: ${{ steps.loadspec.outputs.specfile }}
          API_NAME: "Payment Refund API"
        run: |
          # Use a simple, static version name for this test
          VERSION_NAME="v2.1.0-STATIC-TEST" 
          
          echo "Using existing API ID: $API_ID_FINAL for '$API_NAME'"
          echo "api_id=$API_ID_FINAL" >> $GITHUB_OUTPUT

          # 2. CREATE API VERSION
          echo "Creating new API Version: $VERSION_NAME..."
          
          # CRITICAL TEST: Use simple quoted shell JSON string instead of jq/pipe
          VERSION_PAYLOAD='{"apiVersion": {"name": "'"$VERSION_NAME"'", "baseVersionId": "'"$API_ID_FINAL"'"}}'

          echo "--- DEBUG JSON PAYLOAD (STATIC) ---"
          echo "$VERSION_PAYLOAD"
          echo "-----------------------------------"

          RESPONSE=$(curl -s -X POST \
            "https://api.getpostman.com/apis/$API_ID_FINAL/versions?workspaceId=$WORKSPACE_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -H "Accept: application/vnd.api.v10+json" \
            -d "$VERSION_PAYLOAD") # Pass the static JSON variable

          API_VERSION_ID=$(echo "$RESPONSE" | jq -r '.apiVersion.id')
          if [ -z "$API_VERSION_ID" ] || [ "$API_VERSION_ID" == "null" ]; then
             echo "CRITICAL ERROR: Failed to get API Version ID. Response: $RESPONSE"
             exit 1
          fi
          echo "API Version ID is: $API_VERSION_ID"
          
          # 3. IMPORT SPEC (Upload the file to the new version and link to a new collection)
          echo "Importing spec file $FILE_PATH to API Version $API_VERSION_ID..."
          RESPONSE=$(curl -s -X POST \
            "https://api.getpostman.com/apis/$API_ID_FINAL/versions/$API_VERSION_ID/schemas?workspaceId=$WORKSPACE_ID&modelType=collection" \
            -H "X-Api-Key: $API_KEY" \
            -F "type=openapi" \
            -F "input=file" \
            -F "spec=@$FILE_PATH")

          COLLECTION_ID=$(echo "$RESPONSE" | jq -r '.collection.id')
          
          if [ -z "$COLLECTION_ID" ] || [ "$COLLECTION_ID" == "null" ]; then
             echo "CRITICAL ERROR: Failed to find Collection ID after spec import. Response: $RESPONSE"
             exit 1
          fi

          echo "Successfully created and linked Collection ID: $COLLECTION_ID"
          echo "collection_id=$COLLECTION_ID" >> $GITHUB_OUTPUT
          

      #######################################################################
      # 3. Attach JWT Pre-request Script (Collection Update)
      #######################################################################
      - name: Inject JWT Script
        run: |
          COLLECTION_ID="${{ steps.postman_import.outputs.collection_id }}"
          API_KEY="${{ secrets.POSTMAN_API_KEY }}"

          echo "Injecting JWT pre-request script into collection $COLLECTION_ID"
          
          # Create JWT payload using jq for robustness
          JWT_PAYLOAD=$(jq -n \
            '{"collection": {"event": [{
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// JWT Auth Script: Use pm.environment.get() for client/token details",
                  "const clientId = pm.environment.get(\"clientId\");",
                  "const clientSecret = pm.environment.get(\"clientSecret\");",
                  "const tokenUrl = pm.environment.get(\"tokenUrl\");",
                  "pm.sendRequest({",
                  "  url: tokenUrl,",
                  "  method: \"POST\",",
                  "  header: { \"Content-Type\": \"application/x-www-form-urlencoded\" },",
                  "  body: \"client_id=\" + clientId + \"&client_secret=\" + clientSecret + \"&grant_type=client_credentials\"",
                  "}, function(err, res) { pm.environment.set(\"jwtToken\", res.json().access_token); });"
                ]
              }
            }]}}')

          curl -s -X PUT \
            "https://api.getpostman.com/collections/$COLLECTION_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "$JWT_PAYLOAD"

      #######################################################################
      # 4. (Optional) Run Tests Using Newman
      #######################################################################
      - name: Run Tests
        run: |
          COLLECTION_ID="${{ steps.postman_import.outputs.collection_id }}"

          npm install newman
          echo "Running Newman tests on generated collection $COLLECTION_ID..."
          
          npx newman run "https://api.getpostman.com/collections/$COLLECTION_ID?apikey=${{ secrets.POSTMAN_API_KEY }}"
