name: Sync API Spec → Generate Collection (Local Conversion Fallback)

on:
  push:
    paths:
      - "specs/**/*.yaml"
      - "specs/**/*.yml"
      - "specs/**/*.json"

jobs:
  sync-api:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        shell: bash -e {0}

    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v4 

      #######################################################################
      # 1. Detect and Sanitize Spec File
      #######################################################################
      - name: Detect and Sanitize Spec File
        id: spec
        run: |
          FILE=$(ls specs/payment-refund-api-openapi.*)
          echo "Found spec: $FILE"
          
          iconv -c -f utf-8 -t utf-8 "$FILE" | tr -d '\r' > "$FILE.tmp"
          mv "$FILE.tmp" "$FILE"
          echo "Encoding sanitized."
          echo "specfile=$FILE" >> $GITHUB_OUTPUT

      #######################################################################
      # 2. CREATE SPEC IN SPEC HUB (Source of Truth)
      #######################################################################
      - name: Create Spec in Spec Hub (Source of Truth)
        id: create_spec
        env:
          API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          WORKSPACE_ID: 2bf1dd30-2897-4f0d-abf9-4a02d2970785
          FILE_PATH: ${{ steps.spec.outputs.specfile }}
        run: |
          echo "Creating Spec in Hub (Conceptual Proof)..."
          
          PAYLOAD=$(jq -n \
            --rawfile spec_content "$FILE_PATH" \
            '{
              name: "Payment Refund API",
              type: "OPENAPI:3.0",
              files: [
                {
                  path: "index.yaml",
                  content: $spec_content
                }
              ]
            }')

          curl -s -X POST \
            "https://api.getpostman.com/specs?workspaceId=$WORKSPACE_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" > /dev/null
          
          echo "SUCCESS: Spec entity created/updated in Spec Hub."


      #######################################################################
      # 3. GENERATE COLLECTION LOCALLY
      #######################################################################
      - name: Generate Collection Locally
        id: local_gen
        run: |
          npm install -g openapi-to-postmanv2
          
          npx openapi-to-postmanv2 \
            -s ${{ steps.spec.outputs.specfile }} \
            -o collection.json
            
          echo "SUCCESS: Collection JSON generated locally."


      #######################################################################
      # 4. UPLOAD/UPDATE COLLECTION
      #######################################################################
      - name: Upload or Update Collection
        id: upload_collection
        env:
          API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          WORKSPACE_ID: 2bf1dd30-2897-4f0d-abf9-4a02d2970785
        run: |
          echo "Wrapping collection JSON for upload..."
          
          # Use jq to wrap the collection.json content inside {"collection": ...}
          PAYLOAD=$(jq -n \
            --rawfile collection_content collection.json \
            '{collection: ($collection_content | fromjson)}' )
            
          echo "Uploading generated collection to Postman..."
          
          RESPONSE=$(curl -s -X POST \
            "https://api.getpostman.com/collections?workspaceId=$WORKSPACE_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
            
          COLLECTION_ID=$(echo "$RESPONSE" | jq -r '.collection.id')

          if [[ -z "$COLLECTION_ID" || "$COLLECTION_ID" == "null" ]]; then
            echo "CRITICAL ERROR: Failed to upload collection. Response: $RESPONSE"
            exit 1
          fi

          echo "SUCCESS: Collection uploaded. ID: $COLLECTION_ID"
          echo "collection_id=$COLLECTION_ID" >> $GITHUB_OUTPUT 


      #######################################################################
      # 5. Inject JWT Pre-request Script (FIXED: Fetch-Modify-Put Pattern)
      #######################################################################
      - name: Inject JWT Script
        env:
          API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          COLLECTION_ID: ${{ steps.upload_collection.outputs.collection_id }}
        run: |
          echo "Fetching collection structure for modification..."

          # 1. FETCH the entire collection JSON
          FULL_COLLECTION_RESPONSE=$(curl -s -X GET \
            "https://api.getpostman.com/collections/$COLLECTION_ID" \
            -H "X-Api-Key: $API_KEY")
          
          # Check if the fetch was successful
          if echo "$FULL_COLLECTION_RESPONSE" | jq -e '.collection' > /dev/null; then
              FULL_COLLECTION=$(echo "$FULL_COLLECTION_RESPONSE" | jq '.collection')
          else
              echo "CRITICAL ERROR: Failed to fetch collection for modification. Response: $FULL_COLLECTION_RESPONSE"
              exit 1
          fi

          echo "Modifying collection with JWT script injection..."
          
          # JWT script event structure to inject
          JWT_SCRIPT='[
              {
                "listen": "prerequest",
                "script": {
                  "type": "text/javascript",
                  "exec": [
                    "const clientId = pm.environment.get(\"clientId\");",
                    "const clientSecret = pm.environment.get(\"clientSecret\");",
                    "const tokenUrl = pm.environment.get(\"tokenUrl\");",
                    "",
                    "pm.sendRequest({",
                    "  url: tokenUrl,",
                    "  method: \"POST\",",
                    "  header: {\"Content-Type\": \"application/x-www-form-urlencoded\"},",
                    "  body: \"client_id=\" + clientId + \"&client_secret=\" + clientSecret + \"&grant_type=client_credentials\"",
                    "}, (err, res) => {",
                    "  if (!err) pm.environment.set(\"jwtToken\", res.json().access_token);",
                    "});"
                  ]
                }
              }
            ]'
            
          # 2. MODIFY the fetched collection JSON by adding the 'event' property
          MODIFIED_PAYLOAD=$(echo "$FULL_COLLECTION" | jq --argjson script_event "$JWT_SCRIPT" '. + {event: $script_event}')
          
          # 3. PUT the complete, modified JSON back
          echo "Sending complete, modified collection back to the API..."

          # Note: The API requires the outer "collection" key for the PUT
          RESPONSE=$(curl -s -X PUT \
            "https://api.getpostman.com/collections/$COLLECTION_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"collection\": $MODIFIED_PAYLOAD}") 

          echo "Collection update response: $RESPONSE"

      #######################################################################
      # 6. Run tests using Newman
      #######################################################################
      - name: Run Tests
        run: |
          npm install newman
          COLLECTION_ID="${{ steps.upload_collection.outputs.collection_id }}"

          echo "Running Newman tests…"
          npx newman run "https://api.getpostman.com/collections/$COLLECTION_ID?apikey=${{ secrets.POSTMAN_API_KEY }}"
