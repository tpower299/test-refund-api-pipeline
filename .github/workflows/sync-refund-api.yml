name: Sync API Spec → Generate Collection → Link API

on:
  push:
    paths:
      - "specs/**/*.yaml"
      - "specs/**/*.yml"
      - "specs/**/*.json"

jobs:
  sync-api:
    runs-on: ubuntu-latest
    
    # Exit immediately if a command fails
    defaults:
      run:
        shell: bash -e {0}

    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v4 

      #######################################################################
      # 1. Read Spec File and Get File Path
      #######################################################################
      - name: Load Spec File Path and Type
        id: loadspec
        run: |
          # Finds the single spec file regardless of extension
          FILE=$(ls specs/payment-refund-api-openapi.*)
          
          if [[ "$FILE" =~ \.(yaml|yml)$ ]]; then
              LANG="yaml"
          elif [[ "$FILE" =~ \.json$ ]]; then
              LANG="json"
          else
              echo "Error: Unsupported file extension for $FILE"
              exit 1
          fi

          echo "Spec file found: $FILE"
          echo "specfile=$FILE" >> $GITHUB_OUTPUT

      #######################################################################
      # 1.5 SANITIZE SPEC FILE CONTENT (Ensuring clean transmission)
      #######################################################################
      - name: Sanitize YAML File Encoding
        run: |
          FILE="${{ steps.loadspec.outputs.specfile }}"
          iconv -c -f utf-8 -t utf-8 "$FILE" | tr -d '\r' > "${FILE}.tmp"
          mv "${FILE}.tmp" "$FILE"
          echo "File encoding sanitized."

      #######################################################################
      # 2. PUBLISH SPEC via POSTMAN REST API (FINAL RAW DATA cURL FIX)
      #######################################################################
      - name: Publish Spec via Postman REST API (cURL)
        id: postman_import
        env:
          API_ID_FINAL: 4351c3b1-def3-4d95-9ef5-4ce0dcc42853
          API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          WORKSPACE_ID: 2bf1dd30-2897-4f0d-abf9-4a02d2970785
          FILE_PATH: ${{ steps.loadspec.outputs.specfile }}
          API_NAME: "Payment Refund API"
        run: |
          VERSION_NAME="v2.1.0-build-$(date +%Y%m%d%H%M%S)" 
          
          echo "Using existing API ID: $API_ID_FINAL for '$API_NAME'"
          echo "api_id=$API_ID_FINAL" >> $GITHUB_OUTPUT

          # 2.1 CREATE API VERSION 
          echo "Creating new API Version: $VERSION_NAME..."
          
          # CRITICAL FIX: Pass the minimal JSON payload directly as a raw string 
          # using a Bash Here-Document to avoid file reading/encoding conflicts.
          RESPONSE=$(curl -s -X POST \
            "https://api.getpostman.com/apis/$API_ID_FINAL/versions?workspaceId=$WORKSPACE_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -H "Accept: application/vnd.api.v10+json" \
            -d @- << EOF # Pass data directly from the input stream
{
  "apiVersion": {
    "name": "$VERSION_NAME"
  }
}
EOF
) 
          
          echo "--- DEBUG RAW RESPONSE ---"
          echo "$RESPONSE"
          echo "--------------------------"

          API_VERSION_ID=$(echo "$RESPONSE" | jq -r '.apiVersion.id')
          if [ -z "$API_VERSION_ID" ] || [ "$API_VERSION_ID" == "null" ]; then
             echo "CRITICAL ERROR: Failed to get API Version ID."
             echo "Final REST API Response: $RESPONSE"
             exit 1
          fi
          echo "API Version ID is: $API_VERSION_ID"
          
          # 2.2 IMPORT SPEC (Upload the file to the new version and link to a new collection)
          echo "Importing spec file $FILE_PATH to API Version $API_VERSION_ID..."
          RESPONSE=$(curl -s -X POST \
            "https://api.getpostman.com/apis/$API_ID_FINAL/versions/$API_VERSION_ID/schemas?workspaceId=$WORKSPACE_ID&modelType=collection" \
            -H "X-Api-Key: $API_KEY" \
            -F "type=openapi" \
            -F "input=file" \
            -F "spec=@$FILE_PATH")

          COLLECTION_ID=$(echo "$RESPONSE" | jq -r '.collection.id')
          
          if [ -z "$COLLECTION_ID" ] || [ "$COLLECTION_ID" == "null" ]; then
             echo "CRITICAL ERROR: Failed to find Collection ID after spec import. Response: $RESPONSE"
             exit 1
          fi

          echo "Successfully created and linked Collection ID: $COLLECTION_ID"
          echo "collection_id=$COLLECTION_ID" >> $GITHUB_OUTPUT
          

      #######################################################################
      # 3. Attach JWT Pre-request Script (Collection Update)
      #######################################################################
      - name: Inject JWT Script
        run: |
          COLLECTION_ID="${{ steps.postman_import.outputs.collection_id }}"
          API_KEY="${{ secrets.POSTMAN_API_KEY }}"

          echo "Injecting JWT pre-request script into collection $COLLECTION_ID"
          
          # Create JWT payload using jq for robustness
          JWT_PAYLOAD=$(jq -n \
            '{"collection": {"event": [{
              "listen": "prerequest",
              "script": {
                "type": "text/javascript",
                "exec": [
                  "// JWT Auth Script: Use pm.environment.get(\"clientId\") for client/token details",
                  "const clientId = pm.environment.get(\"clientId\");",
                  "const clientSecret = pm.environment.get(\"clientSecret\");",
                  "const tokenUrl = pm.environment.get(\"tokenUrl\");",
                  "pm.sendRequest({",
                  "  url: tokenUrl,",
                  "  method: \"POST\",",
                  "  header: { \"Content-Type\": \"application/x-www-form-urlencoded\" },",
                  "  body: \"client_id=\" + clientId + \"&client_secret=\" + clientSecret + \"&grant_type=client_credentials\"",
                  "}, function(err, res) { pm.environment.set(\"jwtToken\", res.json().access_token); });"
                ]
              }
            }]}}')

          curl -s -X PUT \
            "https://api.getpostman.com/collections/$COLLECTION_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "$JWT_PAYLOAD"

      #######################################################################
      # 4. (Optional) Run Tests Using Newman
      #######################################################################
      - name: Run Tests
        run: |
          COLLECTION_ID="${{ steps.postman_import.outputs.collection_id }}"

          npm install newman
          echo "Running Newman tests on generated collection $COLLECTION_ID..."
          
          npx newman run "https://api.getpostman.com/collections/$COLLECTION_ID?apikey=${{ secrets.POSTMAN_API_KEY }}"
