name: Sync API Spec → Generate Collection → Link API

on:
  push:
    paths:
      - "specs/**/*.yaml"
      - "specs/**/*.yml"
      - "specs/**/*.json"

jobs:
  sync-api:
    runs-on: ubuntu-latest
    
    # Exit immediately if a command fails
    defaults:
      run:
        shell: bash -e {0}

    steps:
      - uses: actions/checkout@v3

      #######################################################################
      # 1. Read Spec File and Convert to Single-Line String (Advanced Escaping)
      #######################################################################
      - name: Load Spec File Path and Type
        id: loadspec
        run: |
          FILE=$(ls specs/payment-refund-api-openapi.*)
          
          if [[ "$FILE" =~ \.(yaml|yml)$ ]]; then
              LANG="yaml"
          elif [[ "$FILE" =~ \.json$ ]]; then
              LANG="json"
          else
              echo "Error: Unsupported file extension for $FILE"
              exit 1
          fi

          # CRITICAL FIX: Use jq to read the file content and apply perfect JSON string escaping.
          # This resolves the "Invalid character 't'" error which was caused by insufficient escaping
          # of the spec content before nesting it inside the upload JSON body.
          # -R: Read as raw string, -s: Slurp all inputs, '.': Output the raw string.
          CONTENTS=$(jq -Rs '.' "$FILE")
          
          # Remove the outer quotes that jq adds to the string.
          CONTENTS="${CONTENTS:1:-1}"

          echo "specfile=$FILE" >> $GITHUB_OUTPUT
          echo "file_type=$LANG" >> $GITHUB_OUTPUT
          echo "contents=$CONTENTS" >> $GITHUB_OUTPUT
          

      #######################################################################
      # 2. Upload/Update SPEC directly to Spec Hub (Revert to application/json)
      #######################################################################
      - name: Upload Spec to Postman Spec Hub (JSON Payload)
        id: uploadspec
        run: |
          API_NAME="Payment Refund API"
          WORKSPACE_ID="2bf1dd30-2897-4f0d-abf9-4a02d2970785" 
          CONTENTS="${{ steps.loadspec.outputs.contents }}"
          FILE_LANG="${{ steps.loadspec.outputs.file_type }}" 

          echo "Attempting to upload spec for API: $API_NAME to Spec Hub..."

          # --- Use printf to construct the JSON payload to a file ---
          # This uses the perfectly escaped CONTENTS variable.
          printf '{"spec":{"name":"%s","content":"%s","contentType":"%s"}}' \
            "$API_NAME" \
            "$CONTENTS" \
            "$FILE_LANG" \
            > spec_payload.json

          echo "Successfully wrote payload to spec_payload.json."

          # --- POST request using application/json content type (required by Postman) ---
          CREATE_SPEC=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
            "https://api.getpostman.com/specs?workspaceId=$WORKSPACE_ID" \
            -H "X-Api-Key: ${{ secrets.POSTMAN_API_KEY }}" \
            -H "Content-Type: application/json" \
            --data @spec_payload.json) # <-- Read body from the file

          HTTP_STATUS=$(echo "$CREATE_SPEC" | tail -n 1 | awk -F: '{print $2}')
          SPEC_BODY=$(echo "$CREATE_SPEC" | head -n -1)

          echo "--- RAW SPEC UPLOAD RESPONSE (HTTP Status: $HTTP_STATUS) ---"
          echo "$SPEC_BODY"
          echo "------------------------------------------------------------"

          if [ "$HTTP_STATUS" != "200" ] && [ "$HTTP_STATUS" != "201" ]; then
              echo "ERROR: Failed to upload Spec (HTTP $HTTP_STATUS). Check body for details."
              exit 1
          fi

          SPEC_ID=$(echo "$SPEC_BODY" | jq -r ".spec.id")
          
          if [ -z "$SPEC_ID" ] || [ "$SPEC_ID" == "null" ]; then 
            echo "CRITICAL ERROR: Failed to parse SPEC ID from creation response."
            exit 1 
          fi

          echo "Spec ID successfully created/updated: $SPEC_ID"
          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
          
      #######################################################################
      # 3. Generate Collection from Spec 
      #######################################################################
      - name: Generate Collection from Spec
        id: gencoll
        run: |
          SPEC_ID="${{ steps.uploadspec.outputs.spec_id }}"
          
          echo "Generating collection from Spec ID: $SPEC_ID"

          GEN=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST \
            "https://api.getpostman.com/specs/$SPEC_ID/generations/collection" \
            -H "X-Api-Key: ${{ secrets.POSTMAN_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{"options": {"requestParametersResolution": "example", "exampleParametersResolution": "example"}}') 

          HTTP_STATUS=$(echo "$GEN" | tail -n 1 | awk -F: '{print $2}')
          GEN_BODY=$(echo "$GEN" | head -n -1)

          echo "--- RAW GENERATION RESPONSE (HTTP Status: $HTTP_STATUS) ---"
          echo "$GEN_BODY"
          echo "----------------------------------------------------------"

          if [ "$HTTP_STATUS" != "200" ]; then
              echo "ERROR: Collection generation failed (HTTP $HTTP_STATUS)."
              exit 1
          fi

          COLLECTION_ID=$(echo "$GEN_BODY" | jq -r ".collection.id")

          echo "Collection successfully generated: $COLLECTION_ID"
          echo "collection_id=$COLLECTION_ID" >> $GITHUB_OUTPUT

      #######################################################################
      # 4. Attach JWT Pre-request Script (Collection Update)
      #######################################################################
      - name: Inject JWT Script
        run: |
          COLLECTION_ID="${{ steps.gencoll.outputs.collection_id }}"

          echo "Injecting JWT pre-request script into collection $COLLECTION_ID"
          
          curl -s -X PUT \
            "https://api.getpostman.com/collections/$COLLECTION_ID" \
            -H "X-Api-Key: ${{ secrets.POSTMAN_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "{
                  \"collection\": {
                    \"event\": [{
                      \"listen\": \"prerequest\",
                      \"script\": {
                        \"type\": \"text/javascript\",
                        \"exec\": [
                          \"// JWT Auth Script: Use pm.environment.get() for client/token details\",
                          \"const clientId = pm.environment.get('clientId');\",
                          \"const clientSecret = pm.environment.get('clientSecret');\",
                          \"const tokenUrl = pm.environment.get('tokenUrl');\",
                          \"pm.sendRequest({\",
                          \"  url: tokenUrl,\",
                          \"  method: 'POST',\",
                          \"  header: { 'Content-Type': 'application/x-www-form-urlencoded' },\",
                          \"  body: 'client_id=' + clientId + '&client_secret=' + clientSecret + '&grant_type=client_credentials'\",
                          \"}, function(err, res) { pm.environment.set('jwtToken', res.json().access_token); });\"
                        ]
                      }
                    }]
                  }
                }"

      #######################################################################
      # 5. (Optional) Run Tests Using Newman
      #######################################################################
      - name: Run Tests
        run: |
          COLLECTION_ID="${{ steps.gencoll.outputs.collection_id }}"

          npm install -g newman
          echo "Running Newman tests on generated collection $COLLECTION_ID..."
          
          newman run "https://api.getpostman.com/collections/$COLLECTION_ID?apikey=${{ secrets.POSTMAN_API_KEY }}"
