name: Sync API Spec â†’ Generate Collection (Local Conversion & Inject)

on:
  push:
    paths:
      - "specs/**/*.yaml"
      - "specs/**/*.yml"
      - "specs/**/*.json"

jobs:
  sync-api:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        shell: bash -e {0}

    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v4 

      #######################################################################
      # 1. Detect and Sanitize Spec File
      #######################################################################
      - name: Detect and Sanitize Spec File
        id: spec
        run: |
          FILE=$(ls specs/payment-refund-api-openapi.*)
          echo "Found spec: $FILE"
          iconv -c -f utf-8 -t utf-8 "$FILE" | tr -d '\r' > "$FILE.tmp"
          mv "$FILE.tmp" "$FILE"
          echo "Encoding sanitized."
          echo "specfile=$FILE" >> $GITHUB_OUTPUT

      #######################################################################
      # 2. CREATE SPEC IN SPEC HUB (Source of Truth)
      #######################################################################
      - name: Create Spec in Spec Hub (Source of Truth)
        id: create_spec
        env:
          API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          WORKSPACE_ID: 2bf1dd30-2897-4f0d-abf9-4a02d2970785
          FILE_PATH: ${{ steps.spec.outputs.specfile }}
        run: |
          echo "Creating Spec in Hub..."
          PAYLOAD=$(jq -n \
            --rawfile spec_content "$FILE_PATH" \
            '{
              name: "Payment Refund API",
              type: "OPENAPI:3.0",
              files: [
                {
                  path: "index.yaml",
                  content: $spec_content
                }
              ]
            }')

          RESPONSE=$(curl -s -X POST \
            "https://api.getpostman.com/specs?workspaceId=$WORKSPACE_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          echo "Spec creation response: $RESPONSE"

          SPEC_ID=$(echo "$RESPONSE" | jq -r '.id')

          if [[ -z "$SPEC_ID" || "$SPEC_ID" == "null" ]]; then
            echo "CRITICAL ERROR: Failed to get Spec ID. Response: $RESPONSE"
            exit 1
          fi

          echo "SUCCESS: Spec ID: $SPEC_ID"
          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT

      #######################################################################
      # 3. GENERATE AND INJECT SCRIPT LOCALLY
      #######################################################################
      - name: Generate Collection and Inject Script Locally
        id: local_gen_inject
        run: |
          npm install -g openapi-to-postmanv2
          
          # Generate collection JSON locally
          npx openapi-to-postmanv2 \
            -s ${{ steps.spec.outputs.specfile }} \
            -o collection.json
          
          echo "Collection JSON generated."

          # JWT pre-request script
          JWT_SCRIPT='[
              {
                "listen": "prerequest",
                "script": {
                  "type": "text/javascript",
                  "exec": [
                    "const clientId = pm.environment.get(\"clientId\");",
                    "const clientSecret = pm.environment.get(\"clientSecret\");",
                    "const tokenUrl = pm.environment.get(\"tokenUrl\");",
                    "pm.sendRequest({",
                    "  url: tokenUrl,",
                    "  method: \"POST\",",
                    "  header: {\"Content-Type\": \"application/x-www-form-urlencoded\"},",
                    "  body: \"client_id=\" + clientId + \"&client_secret=\" + clientSecret + \"&grant_type=client_credentials\"",
                    "}, (err, res) => {",
                    "  if (!err) pm.environment.set(\"jwtToken\", res.json().access_token);",
                    "});"
                  ]
                }
              }
            ]'

          # Inject JWT script into the collection
          echo "Injecting JWT script into collection.json..."
          jq --argjson script_event "$JWT_SCRIPT" '.event = $script_event' collection.json > collection_modified.json
          mv collection_modified.json collection.json
          
          echo "SUCCESS: Collection JSON generated and script injected."

      #######################################################################
      # 4. UPLOAD FINAL COLLECTION
      #######################################################################
      - name: Upload Final Collection
        id: upload_collection
        env:
          API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          WORKSPACE_ID: 2bf1dd30-2897-4f0d-abf9-4a02d2970785
        run: |
          echo "Wrapping collection JSON for upload..."
          PAYLOAD=$(jq -n \
            --rawfile collection_content collection.json \
            '{collection: ($collection_content | fromjson)}' )
            
          echo "Uploading generated collection to Postman..."
          RESPONSE=$(curl -s -X POST \
            "https://api.getpostman.com/collections?workspaceId=$WORKSPACE_ID" \
            -H "X-Api-Key: $API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
            
          echo "Upload response (raw): $RESPONSE"
          COLLECTION_ID=$(echo "$RESPONSE" | jq -r '.collection.id')
          if [[ -z "$COLLECTION_ID" || "$COLLECTION_ID" == "null" ]]; then
            echo "CRITICAL ERROR: Failed to upload collection. Response: $RESPONSE"
            exit 1
          fi
          echo "SUCCESS: Collection uploaded. ID: $COLLECTION_ID"
          echo "collection_id=$COLLECTION_ID" >> $GITHUB_OUTPUT

      #######################################################################
      # 5. Run tests using Newman
      #######################################################################
      - name: Run Tests
        run: |
          npm install newman
          echo "Running Newman tests against local collection.json..."
          npx newman run collection.json --insecure

