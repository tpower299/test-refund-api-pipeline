name: Sync ALL API Specs â†’ Generate Collections (Idempotent Scaling Pattern)

on:
  push:
    paths:
      - "specs/**/*.yaml" 
      - "specs/**/*.yml"
      - "specs/**/*.json"
  workflow_dispatch:

jobs:
  sync-apis:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash -e {0}
    env:
      POSTMAN_WORKSPACE_ID: ${{ secrets.POSTMAN_WORKSPACE_ID }} 
      POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
      MOCK_SERVER_URL: https://ac1d1bb2-eba1-4c5e-b492-9483f4410770.mock.pstmn.io
      AUTH_SERVER_URL: https://postman-echo.com/post

    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v4
      
      - name: Install Dependencies (Newman, jq, Local Converter)
        run: |
          # Keep the local converter for local collection generation as it worked for you
          npm install -g openapi-to-postmanv2 newman 
          sudo apt-get install -y jq 

      #######################################################################
      # CORE LOOP: Process Every Spec File Found in the Folder (Idempotency starts here)
      #######################################################################
      - name: Process and Sync All Specs (Idempotent Upsert)
        id: spec_processor
        run: |
          # Define JWT script once
          JWT_SCRIPT='[ { "listen": "prerequest", "script": { "type": "text/javascript", "exec": [ "// Advanced JWT Auth: Checks expiry and refreshes token", "const clientId = pm.environment.get(\"clientId\");", "const clientSecret = pm.environment.get(\"clientSecret\");", "const tokenUrl = pm.environment.get(\"tokenUrl\");", "const cachedToken = pm.environment.get(\"jwtToken\");", "const tokenExpiry = parseInt(pm.environment.get(\"tokenExpiry\"));", "", "// Check if token is valid (exists AND expiry time is > 30s in the future)", "if (cachedToken && tokenExpiry && Date.now() < (tokenExpiry - 30000)) {", "    pm.request.headers.upsert({key: \"Authorization\", value: \"Bearer \" + cachedToken});", "    return; // Skip token request", "}", "", "// Request new token", "pm.sendRequest({", "    url: tokenUrl,", "    method: \"POST\",", "    header: {\"Content-Type\": \"application/x-www-form-urlencoded\"},", "    body: {mode: \"urlencoded\", urlencoded: [{key: \"grant_type\", value: \"client_credentials\"}, {key: \"client_id\", value: clientId}, {key: \"client_secret\", value: clientSecret}]} ", "}, (err, response) => {", "    if (err || response.code !== 200) {", "        console.error(\"Token request failed:\", err || response.status);", "        return;", "    }", "    const jsonData = response.json();", "    const token = jsonData.access_token;", "    const expires_in_ms = jsonData.expires_in * 1000; ", "    pm.environment.set(\"jwtToken\", token);", "    pm.environment.set(\"tokenExpiry\", Date.now() + expires_in_ms);", "    pm.request.headers.upsert({key: \"Authorization\", value: \"Bearer \" + token});", "});" ] } } ]'

          # Use find to list all spec files and loop through them
          find specs -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) | while read SPEC_FILE; do
            
            # --- Setup API Name and Payloads ---
            API_NAME=$(basename "$SPEC_FILE")
            API_NAME=${API_NAME%.*} # Remove extension
            # Format API Name nicely for Postman Spec Hub
            POSTMAN_SPEC_NAME=$(echo "$API_NAME" | sed 's/-/_/g' | sed 's/_api_openapi//g' | awk '{for(i=1;i<=NF;i++){ $i=toupper(substr($i,1,1)) tolower(substr($i,2))}}1')
            
            echo "--- Starting Ingestion for API: $POSTMAN_SPEC_NAME ($SPEC_FILE) ---"

            # 1. Sanitize the file (Keep your existing iconv logic inside the loop)
            iconv -c -f utf-8 -t utf-8 "$SPEC_FILE" | tr -d '\r' > "$SPEC_FILE.tmp"
            mv "$SPEC_FILE.tmp" "$SPEC_FILE"

            SPEC_PAYLOAD=$(jq -n \
              --arg name "$POSTMAN_SPEC_NAME" \
              --rawfile content "$SPEC_FILE" \
              '{ name: $name, type: "OPENAPI:3.0", files: [{ path: "index.yaml", content: $content }] }')

            # --- 2. IDEMPOTENT SPEC UPSERT (Search -> Act) ---
            
            ALL_SPECS_RESPONSE=$(curl -s -X GET \
              "https://api.getpostman.com/specs?workspaceId=$POSTMAN_WORKSPACE_ID" \
              -H "X-Api-Key: $POSTMAN_API_KEY")

            EXISTING_SPEC_ID=$(echo "$ALL_SPECS_RESPONSE" | jq -r ".specs[] | select(.name==\"$POSTMAN_SPEC_NAME\") | .id")

            REQUEST_METHOD="POST"
            TARGET_URL="https://api.getpostman.com/specs?workspaceId=$POSTMAN_WORKSPACE_ID"
            SPEC_ID=""
            
            if [ -n "$EXISTING_SPEC_ID" ]; then
              echo "  Found existing Spec ID: $EXISTING_SPEC_ID. Switching to UPDATE (PUT)."
              REQUEST_METHOD="PUT"
              TARGET_URL="https://api.getpostman.com/specs/$EXISTING_SPEC_ID"
              SPEC_ID="$EXISTING_SPEC_ID"
            else
              echo "  Spec not found. Switching to CREATE (POST)."
            fi

            SPEC_RESPONSE=$(curl -s -X $REQUEST_METHOD \
              "$TARGET_URL" \
              -H "X-Api-Key: $POSTMAN_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$SPEC_PAYLOAD")

            if [ "$REQUEST_METHOD" == "POST" ]; then
                SPEC_ID=$(echo "$SPEC_RESPONSE" | jq -r '.spec.id')
            fi
            
            if [[ -z "$SPEC_ID" || "$SPEC_ID" == "null" ]]; then
                echo "CRITICAL ERROR: Failed to create/update spec for $POSTMAN_SPEC_NAME."
                echo "RAW RESPONSE BODY: $SPEC_RESPONSE"
                continue 
            fi
            echo "1. Successful $REQUEST_METHOD. Final Spec ID: $SPEC_ID"


            # --- 3. GENERATE COLLECTION LOCALLY (Using your working local tool) ---
            
            COLLECTION_FILENAME="collection_${SPEC_ID}.json"
            npx openapi-to-postmanv2 \
                -s "$SPEC_FILE" \
                -o "$COLLECTION_FILENAME"
            
            if [ ! -f "$COLLECTION_FILENAME" ]; then
                echo "CRITICAL ERROR: Failed to generate local collection for $POSTMAN_SPEC_NAME."
                continue
            fi
            echo "2. Generated local collection file: $COLLECTION_FILENAME"


            # --- 4. UPLOAD/UPDATE COLLECTION ---
            
            UPLOAD_PAYLOAD=$(jq -n \
                --rawfile collection_content "$COLLECTION_FILENAME" \
                '{collection: ($collection_content | fromjson)}' )
            
            # Search for existing collection by name (Optional, but robust)
            ALL_COLLECTIONS_RESPONSE=$(curl -s -X GET \
                "https://api.getpostman.com/collections?workspaceId=$POSTMAN_WORKSPACE_ID" \
                -H "X-Api-Key: $POSTMAN_API_KEY")

            EXISTING_COLLECTION_ID=$(echo "$ALL_COLLECTIONS_RESPONSE" | jq -r ".collections[] | select(.name==\"$POSTMAN_SPEC_NAME\") | .id")

            COL_REQUEST_METHOD="POST"
            COL_TARGET_URL="https://api.getpostman.com/collections?workspaceId=$POSTMAN_WORKSPACE_ID"
            COLLECTION_ID=""
            
            if [ -n "$EXISTING_COLLECTION_ID" ]; then
              # If collection exists, use PUT to update it
              COL_REQUEST_METHOD="PUT"
              COL_TARGET_URL="https://api.getpostman.com/collections/$EXISTING_COLLECTION_ID"
              COLLECTION_ID="$EXISTING_COLLECTION_ID"
            fi

            COL_RESPONSE=$(curl -s -X $COL_REQUEST_METHOD \
              "$COL_TARGET_URL" \
              -H "X-Api-Key: $POSTMAN_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$UPLOAD_PAYLOAD")
            
            if [ "$COL_REQUEST_METHOD" == "POST" ]; then
                COLLECTION_ID=$(echo "$COL_RESPONSE" | jq -r '.collection.id')
            fi

            if [[ -z "$COLLECTION_ID" || "$COLLECTION_ID" == "null" ]]; then
                echo "CRITICAL ERROR: Failed to $COL_REQUEST_METHOD collection for $POSTMAN_SPEC_NAME."
                echo "RAW RESPONSE BODY: $COL_RESPONSE"
                continue
            fi
            echo "3. Successful $COL_REQUEST_METHOD. Final Collection ID: $COLLECTION_ID"

            # --- 5. INJECT JWT PRE-REQUEST SCRIPT (Fetch-Modify-Put) ---
            
            # Fetch Collection JSON
            FULL_COLLECTION_RESPONSE=$(curl -s -X GET "https://api.getpostman.com/collections/$COLLECTION_ID" -H "X-Api-Key: $POSTMAN_API_KEY")
            FULL_COLLECTION=$(echo "$FULL_COLLECTION_RESPONSE" | jq '.collection')
            
            # Modify and Push Update
            MODIFIED_PAYLOAD=$(echo "$FULL_COLLECTION" | jq --argjson script_event "$JWT_SCRIPT" '. + {event: $script_event}')
            
            curl -s -X PUT \
              "https://api.getpostman.com/collections/$COLLECTION_ID" \
              -H "X-Api-Key: $POSTMAN_API_KEY" \
              -H "Content-Type: application/json" \
              -d "{\"collection\": $MODIFIED_PAYLOAD}" > /dev/null
                      
            echo "4. SUCCESS: Collection updated with advanced JWT script."

            # --- 6. NEWMAN TEST RUN (Validation) ---
            echo "5. Running Newman validation for $POSTMAN_SPEC_NAME..."
            npx newman run "https://api.getpostman.com/collections/$COLLECTION_ID?apikey=$POSTMAN_API_KEY" \
              --insecure \
              --env-var "baseUrl=$MOCK_SERVER_URL" \
              --env-var "tokenUrl=$AUTH_SERVER_URL" \
              --env-var "clientId=mock_client" \
              --env-var "clientSecret=mock_secret"
            
            echo "--- Finished Ingestion for $POSTMAN_SPEC_NAME ---"
            
          done

      #######################################################################
      # 7. CREATE DEV ENVIRONMENT (Runs once outside the loop)
      #######################################################################
      - name: Create Base Dev Environment (Singleton)
        run: |
          ENV_PAYLOAD=$(jq -n \
            --arg baseUrl "$MOCK_SERVER_URL" \
            --arg tokenUrl "$AUTH_SERVER_URL" \
            '{              "environment": {                "name": "Payment Processing - Dev",                "values": [                  { "key": "baseUrl", "value": $baseUrl, "enabled": true },                  { "key": "tokenUrl", "value": $tokenUrl, "enabled": true },                  { "key": "clientId", "value": "dev-client-id-internal", "enabled": true },                  { "key": "clientSecret", "value": "dev-secret-internal", "enabled": true },                  { "key": "jwtToken", "value": "", "enabled": true },                  { "key": "tokenExpiry", "value": "0", "enabled": true }                ]              }            }')
          
          HTTP_CODE=$(curl -X POST \
            "https://api.getpostman.com/environments?workspaceId=$POSTMAN_WORKSPACE_ID" \
            -H "X-Api-Key: $POSTMAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$ENV_PAYLOAD" \
            -o response_env_body.json \
            -w "%{http_code}")
                    
          if [[ "$HTTP_CODE" != "200" ]]; then
            echo "WARNING: Environment creation failed (possibly exists or API Key issue). Status: $HTTP_CODE"
          else
            ENV_ID=$(cat response_env_body.json | jq -r '.environment.id')
            echo "SUCCESS: Dev Environment created. ID: $ENV_ID"
          fi
